
                         +-----------------+
                         |      CS 406     |
                         |   PROJECT ONE   |
                         | DESIGN DOCUMENT |
                         +-----------------+

---- GROUP ----

Angela Shi <shiy@lafayette.edu>
James Nigro <nigroj@lafayette.edu>
Ingrid Rumbaugh <rumbaughi@lafayette.edu>
Kerry Stranick <stranick@lafayette.edu>

---- PRELIMINARIES ----
Currently, this is an unfinished version of our design document of priority schedling.

                              PRIORITY SCHEDULING
                                     ====

---- DATA STRUCTURES ----

>> Copy here the declaration of each new or changed `struct' or `struct'
>> member, global or static variable, `typedef', or enumeration.
>> Identify the purpose of each in 25 words or less.

Added to struct thread:

  /* Members for implementing priority scheduling */
  struct list donation_list;           /* Contains threads that are waiting on the lock that the 
                                          current thread owns. */
  struct list_elem donation_list_elem; /* Contains the the list elements of the threads that are 
                                          waiting on the lock. */
  struct lock* wait_on_lock;           /* Denotes which lock the waiting thread is currently
                                          waiting on. */
  int old_priority;                    /* Used for saving and restoring the priority of the
                                          donating thread. */

---- ALGORITHMS ----

>> Briefly describe your implementation of priority scheduling and how it
>> interacts with thread termination.

A new thread (call it T1)'s priority is set when it is created in the thread_create() call.
Once T1's priority is set, it temporarily becomes the currently running thread by making
the currently running thread (call it T2) yield. T1's priority is checked against the
priority of T2; if T1's priority is lower than T2's priority, it yields and T2 becomes the
currently running thread again. Otherwise, T2 remains yielded and T1 resumes its execution.

...


---- SYNCHRONIZATION ----

>> An operating system kernel is a complex, multithreaded program,
>> in which synchronizing multiple threads can be difficult. How
>> did you choose to synchronize timer_sleep()?

...

---- RATIONALE ----

>> Critique your design, pointing out advantages and disadvantages in
>> your design choices.

...
